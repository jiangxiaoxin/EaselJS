！！！
依然没有解决如何减少绘制次数或者说数量的问题，每次绘制都是按照 display list 从头渲染。
虽然有bitmapCache，但这个只能对于内部的内容不变的DisplayObject才有效，如果内容一致在变，用了反而不好。而且数量多了也会增加内存消耗，毕竟
要对每个对象设置一个离屏的canvas。

那这里就这样优化下:指定缓存用的canvas的数量，并且设置画布的大小，比如2000×2000，如果不够了再增加，这样子减少离屏canvas的量，就能减少内存耗用了。
问题就是要将显示对象合理的装入这个“池子”里，找到合适的画布，并写入。

那这样子，会不会又增加了很多计算量呢？要做比对，从中找出合理的规则。

从根容器开始，也就是 Stage，遍历整个 display list，看哪个需要更新，特定更新此区域？但这样子一帧内循环的是不是又增加很多工作量呢？

可以这样：如果某一级容器发生改变了，那就不要继续比对它的子对象了，就都认定要重新渲染。





1.bitmapCache是干嘛的？ 怎么实现的？

    就是个缓存类，通过离屏渲染提高性能，将 DisplayObject的内容写入到离屏的 canvas上，如果传入了指定 canvas，就写到指定的上。如果没有
    指定就 document.createElement创建一个。

2.displayobject的matrix计算？getConcatenatedMatrix ？

displayobject getMatrix 得到的矩阵是它自己的矩阵，相对于其父容器的变换，
getConcatenatedMatrix 得到的是其从根容器到自己累积起来的变换矩阵，也就是相对于当前绘图窗口来说的


3.Matrix2d ！！！
此处采用的是【左乘变换】，也是最流行的方式。其他不少框架用的【右乘】
a  c  tx
b  d  ty
0  0  1

左乘变换后坐标 [x,y] => [x',y']
x' = a * x + c * y + tx
y' = b * x + d * y + ty

初始化 matrix ： a = 1 ,c = 0, tx = 0, b = 0, d = 1, ty = 0 就是下面的单位矩阵，采用该矩阵，不会对原来的点[x,y]有任何影响
1 0 0
0 1 0
0 0 1

平移：a  = 1， c = 0, b = 0, d = 1,
1 0 tx
0 1 ty
0 0 1

x' = x + tx
y' = y + ty

缩放 c = 0, tx = 0, b = 0 ty = 0
a 0 0
0 d 0
0 0 1

x' = a * x
y' = d * y

旋转 tx=0 ty=0
a c 0
b d 0
0 0 1
x' = a * x + c * y
y' = b * x + d * y

a = cos(angle)
c = -sin(angle)
b = sin(angle)
d = cos(angle)


初始（x，y），夹角是a，旋转b角度之后，变成（x'，y'）, 两次到原点的距离是一样的

x' = r * cos(a + b) = r * cos(a) * cos(b) - r * sin(a) * sin(b)
y' = r * sin(a + b) = r * sin(a) * cos(b) + r * cos(a) * sin(b)

x = r * cos(a)
y = r * sin(a)

上面的公式就变了 ：

x' = cos(b) * x - sin(b) * y
y' = sin(b) * x + cos(b) * y

==>:

a = cos(angle)
c = -sin(angle)
b = sin(angle)
d = cos(angle)


skew 就是让x的值跟y的值， y的值跟x的值挂上关系
x' = x + c * y + 0
或者
y' = b * x + y + 0

左乘的意思是，给一个变换的矩阵，放在左边，然后乘以表示坐标的3×1矩阵，得到最后的坐标的矩阵.

| a c tx |   | x |    | a * x + c * y + tx |
| b d ty | * | y | => | b * x + d * y + ty |
| 0 0 1  |   | 1 |    | 1                  |

如果拆分开矩阵，比如，先 translate 再 scale 再 rotate，其实最后也是 transformMatrix * positionMatrix => newPositionMatrix

所以就是把所有的变换最后合成一个矩阵，然后这个最后的矩阵再左乘原来的坐标矩阵得到新的坐标矩阵

而在合成这个最后的矩阵的过程中，矩阵之间是按照顺序右乘的。矩阵之间的顺序搞错，得出的变换可就完全不同了。

translateMatrix * scaleMatrix * rotateMatrix => transformMatrix

而在localToGlobal 和 globalToLocal 计算时，要计算出总的变换矩阵。 这个矩阵是从根容器上一级一级变换过来的，也符合上面的右乘顺序：

根容器Matrix × 次根容器Matrix × 次根容器Matrix × .... × 当前显示对象自身的Matrix。

之所以这个顺序，是因为子对象的最终变换，就是在上一层容器的变换的基础上叠加的，跟先 translate 然后 scale 然后 rotate 一个道理。

DisplayObject.prototype.getConcatenatedMatrix 从当前容器开始，一层层往上去乘，所以都是 prependMatrix ，左乘父容器的矩阵。

这个反向去左乘能成立，是因为矩阵的乘法满足结合律： A * B * C == (A * B) * C == A * (B * C)



1. createjs

events
    - Event
        定义个事件类
    - EventDispatcher
        事件调度器类，发出事件，监听事件。
        静态类方法 initialize 可以扩展一个对象，让它可以监听事件，发出事件


2. easeljs

geom
    - DisplayProps
        一个数据类，显示对象的 visible alpha 等属性的集合。
    - Matrix2D
        数学计算类，2维的矩阵计算，用于显示对象的变换。
    - Point
        二维点的定义
    - Rectangle
        矩形的数学类，定义个矩形，判断矩形是否相交，是否包含，包含的最小矩形等方法。


display

    - Stage => Container
        场景类，视图的管理和渲染。

    - DisplayObject

    - Container => DisplayObject

    - Bitmap

    - Graphics

    - Shape

    - BitmapCache







