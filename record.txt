1.bitmapCache是干嘛的？ 怎么实现的？


2.displayobject的matrix计算？getConcatenatedMatrix ？
displayobject getMatrix 得到的矩阵是它自己的矩阵，相对于其父容器的变换，
getConcatenatedMatrix 得到的是其一直到跟容器的矩阵，相对于根容器，也就是 Stage，一般不会给Stage做变换，所以相当于针对canvas显示窗口的变换。
如果Stage发生变换了，那就不是相对于 canvas显示窗口了。


3.Matrix2d ！！！
此处采用的是【左乘变换】，也是最流行的方式。其他不少框架用的【右乘】
a  c  tx
b  d  ty
0  0  1

左乘变换后坐标 [x,y] => [x',y']
x' = a * x + c * y + tx
y' = b * x + d * y + ty

初始化 matrix ： a = 1 ,c = 0, tx = 0, b = 0, d = 1, ty = 0 就是下面的单位矩阵，采用该矩阵，不会对原来的点[x,y]有任何影响
1 0 0
0 1 0
0 0 1

平移：a  = 1， c = 0, b = 0, d = 1,
1 0 tx
0 1 ty
0 0 1

x' = x + tx
y' = y + ty

缩放 c = 0, tx = 0, b = 0 ty = 0
a 0 0
0 d 0
0 0 1

x' = a * x
y' = d * y

旋转 tx=0 ty=0
a c 0
b d 0
0 0 1
x' = a * x + c * y
y' = b * x + d * y

a = cos(angle)
c = -sin(angle)
b = sin(angle)
d = cos(angle)


初始（x，y），夹角是a，旋转b角度之后，变成（x'，y'）, 两次到原点的距离是一样的

x' = r * cos(a + b) = r * cos(a) * cos(b) - r * sin(a) * sin(b)
y' = r * sin(a + b) = r * sin(a) * cos(b) + r * cos(a) * sin(b)

x = r * cos(a)
y = r * sin(a)

上面的公式就变了 ：

x' = cos(b) * x - sin(b) * y
y' = sin(b) * x + cos(b) * y

==>:

a = cos(angle)
c = -sin(angle)
b = sin(angle)
d = cos(angle)


skew 就是让x的值跟y的值， y的值跟x的值挂上关系
x' = x + c * y + 0
或者
y' = b * x + y + 0

左乘的意思是，给一个变换的矩阵，放在左边，然后乘以表示坐标的3×1矩阵，得到最后的坐标的矩阵.

| a c tx |   | x |    | a * x + c * y + tx |
| b d ty | * | y | => | b * x + d * y + ty |
| 0 0 1  |   | 1 |    | 1                  |

如果拆分开矩阵，比如，先 translate 再 scale 再 rotate，其实最后也是 transformMatrix * positionMatrix => newPositionMatrix

所以就是把所有的变换最后合成一个矩阵，然后这个最后的矩阵再左乘原来的坐标矩阵得到新的坐标矩阵

而在合成这个最后的矩阵的过程中，矩阵之间是按照顺序右乘的。矩阵之间的顺序搞错，得出的变换可就完全不同了。

translateMatrix * scaleMatrix * rotateMatrix => transformMatrix

而在localToGlobal 和 globalToLocal 计算时，要计算出总的变换矩阵。 这个矩阵是从根容器上一级一级变换过来的，也符合上面的右乘顺序：

根容器Matrix × 次根容器Matrix × 次根容器Matrix × .... × 当前显示对象自身的Matrix。

之所以这个顺序，是因为子对象的最终变换，就是在上一层容器的变换的基础上叠加的，跟先 translate 然后 scale 然后 rotate 一个道理。

DisplayObject.prototype.getConcatenatedMatrix 从当前容器开始，一层层往上去乘，所以都是 prependMatrix ，左乘父容器的矩阵。

这个反向去左乘能成立，是因为矩阵的乘法满足结合律： A * B * C == (A * B) * C == A * (B * C)






