1.bitmapCache是干嘛的？ 怎么实现的？


2.displayobject的matrix计算？getConcatenatedMatrix ？
displayobject getMatrix 得到的矩阵是它自己的矩阵，相对于其父容器的变换，
getConcatenatedMatrix 得到的是其一直到跟容器的矩阵，相对于根容器，也就是 Stage，一般不会给Stage做变换，所以相当于针对canvas显示窗口的变换。
如果Stage发生变换了，那就不是相对于 canvas显示窗口了。


3.Matrix2d ！！！
此处采用的是【左乘变换】，也是最流行的方式。其他不少框架用的【右乘】
a  c  tx
b  d  ty
0  0  1

左乘变换后坐标 [x,y] => [x',y']
x' = a * x + c * y + tx
y' = b * x + d * y + ty

初始化matrix：a = 1 ,c = 0, tx = 0, b = 0, d = 1, ty = 0 就是下面的单位矩阵，采用该矩阵，不会对原来的点[x,y]有任何影响
1 0 0
0 1 0
0 0 1

平移：a  = 1， c = 0, b = 0, d = 1,
1 0 tx
0 1 ty
0 0 1

x' = x + tx
y' = y + ty

缩放 c = 0, tx = 0, b = 0 ty = 0
a 0 0
0 d 0
0 0 1

x' = a * x
y' = d * y

旋转 tx=0 ty=0
a c 0
b d 0
0 0 1
x' = a * x + c * y
y' = b * x + d * y

a = cos(angle)
c = -sin(angle)
b = sin(angle)
d = cos(angle)


初始（x，y），夹角是a，旋转b角度之后，变成（x'，y'）, 两次到原点的距离是一样的

x' = r * cos(a + b) = r * cos(a) * cos(b) - r * sin(a) * sin(b)
y' = r * sin(a + b) = r * sin(a) * cos(b) + r * cos(a) * sin(b)

x = r * cos(a)
y = r * sin(a)

上面的公式就变了 ：

x' = cos(b) * x - sin(b) * y
y' = sin(b) * x + cos(b) * y

==>:

a = cos(angle)
c = -sin(angle)
b = sin(angle)
d = cos(angle)


skew 就是让x的值跟y的值， y的值跟x的值挂上关系
x' = x + c * y + 0
或者
y' = b * x + y + 0







